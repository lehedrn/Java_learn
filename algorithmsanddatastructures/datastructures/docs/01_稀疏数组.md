# 稀疏数组

在日常编程中，我们经常会处理包含大量相同元素（例如 0、空值或默认值）的二维数据。
如果仍然用普通的二维数组去存储这些数据，就会造成严重的空间浪费。
**稀疏数组（Sparse Array）** 正是为了解决这种问题而出现的一种高效数据结构。

---

## 一、什么是稀疏数组

**稀疏数组（Sparse Array）** 是一种仅存储“非默认值”元素的数据结构。
它通过记录这些元素的**位置（行、列）**和**实际值**，在保证信息完整的前提下，大幅节省存储空间。

举个例子：

假设我们有一个 11×11 的棋盘，用二维数组表示：

```
0 0 0 0 0 0 0 0 0 0 0
0 0 1 0 0 0 0 0 0 0 0
0 0 0 2 0 0 0 0 0 0 0
...
```

这里大部分元素都是 0，仅有少数几个位置存放了棋子。
若用稀疏数组，只需记录非零元素的位置和值即可，例如：

| 行  | 列  | 值 |                   |
| -- | -- | - | ----------------- |
| 11 | 11 | 3 | ← 原数组行数、列数、非零元素个数 |
| 1  | 2  | 1 |                   |
| 2  | 3  | 2 |                   |
| 4  | 5  | 1 |                   |

这样就从原来的 121 个元素压缩成了 4 条记录。

---

## 二、稀疏数组的优势与局限

### ✅ 优势

* **节省空间**：只保存非零元素，极大减少存储需求。
* **便于序列化**：易于存储和传输，如保存棋盘状态、稀疏矩阵文件等。
* **数据稀疏时效率高**：适合高维但稀疏的数据（如推荐系统、文本特征向量）。

### ⚠️ 局限

* **随机访问效率降低**：需要额外查表才能找到特定元素。
* **更新操作复杂**：插入、删除都需维护结构的一致性。
* **不适合稠密数据**：若非零元素过多，反而比普通数组更占空间。

---

## 三、稀疏数组的常见实现方式

根据使用场景和访问需求不同，稀疏数组可以有多种实现方式。以下是常见的几种。

---

### 1. 列表（List）结构

这是最直观、最简单的表示方法。
用一张“坐标表”记录所有非零元素的行、列和值。

| 行  | 列  | 值 |
| -- | -- | - |
| 11 | 11 | 3 |
| 1  | 2  | 1 |
| 2  | 3  | 2 |
| 4  | 5  | 1 |

**特点：**

* 结构简单，易于理解；
* 适合文件存储、数据还原；
* 查找效率较低（需遍历整个表）。

**适用场景：** 棋盘类游戏、图像像素矩阵、日志序列化等。

---

### 2. 字典（Dictionary / Map）结构

以 `(行, 列)` 为键，以值为内容存储非零元素：

```
{
  (1, 2): 1,
  (2, 3): 2,
  (4, 5): 1
}
```

**特点：**

* 查找效率高（键值映射 O(1)）；
* 结构灵活，便于插入和删除；
* 占用空间略高于纯数组结构。

**适用场景：** Python 程序中的稀疏数据处理、机器学习特征存储。

---

### 3. 三元组（Triplet List / COO 格式）

在科学计算中，通常用三个等长数组记录稀疏矩阵的行、列和值：

```
row = [0, 1, 1, 2]
col = [2, 0, 3, 1]
data = [3, 2, 4, 5]
```

这种结构被称为 **COO（Coordinate List）格式**，也是“三元组表示法”。
每个索引 `i` 对应一个非零元素 `(row[i], col[i], data[i])`。

**特点：**

* 插入和构建简单；
* 可直接进行排序或批量合并；
* 在矩阵运算前通常会转换为更高效的格式（CSR 或 CSC）。

**适用场景：** 构建阶段的数据加载、矩阵初始化。

---

### 4. 压缩稀疏行（CSR）与压缩稀疏列（CSC）

这两种是科学计算和机器学习框架中最常用的稀疏矩阵存储格式。

#### （1）CSR（Compressed Sparse Row）

用三个数组表示：

* `data`：所有非零元素值；
* `indices`：对应的列索引；
* `indptr`：每一行的起始位置索引。

例如矩阵：

```
[ 0  0  3  0 ]
[ 2  0  0  4 ]
[ 0  5  0  0 ]
```

压缩后为：

```
data    = [3, 2, 4, 5]
indices = [2, 0, 3, 1]
indptr  = [0, 1, 3, 4]
```

`indptr` 的含义是：

* 第 0 行元素范围：data[0:1]
* 第 1 行元素范围：data[1:3]
* 第 2 行元素范围：data[3:4]

**特点：**

* 按行访问非常高效；
* 存储连续、占用小；
* 不易修改结构（插入/删除麻烦）。

#### （2）CSC（Compressed Sparse Column）

CSC（压缩稀疏列）与 CSR 类似，只是按列压缩。
非常适合按列操作的算法（如转置、求解线性方程组）。

**适用场景：**
矩阵乘法、梯度计算、机器学习与数值优化算法。

---

## 四、常见结构对比

| 实现方式      | 查找效率 | 内存占用 | 插入修改 | 典型场景          |
| --------- | ---- | ---- | ---- | ------------- |
| 列表结构      | 低    | 高    | 简单   | 棋盘保存、日志记录     |
| 字典结构      | 高    | 中    | 灵活   | Python 稀疏特征存储 |
| 三元组（COO）  | 中    | 中    | 易构建  | 稀疏矩阵加载阶段      |
| CSR / CSC | 高    | 低    | 不便   | 科学计算、矩阵运算     |

---

## 五、应用场景举例

* **游戏存储**：围棋、五子棋等棋盘状态。
* **图的邻接矩阵**：只记录存在的边。
* **机器学习特征向量**：文本向量、推荐系统用户行为数据。
* **图像处理**：只存储非零像素的稀疏图像。
* **数值计算**：大规模线性方程组、矩阵分解。

---

## 六、总结

稀疏数组的设计思想非常简单：

> **“用最小的存储，保留完整的信息。”**

它在不同场景中有多种实现方式：

* 简单存储用列表；
* 快速访问用字典；
* 科学计算用 COO / CSR / CSC。

在现代科学计算与 AI 框架中，CSR 与 CSC 已成为稀疏矩阵的标准表示形式。
理解它们的结构，不仅能帮助我们优化内存使用，更能深入掌握底层计算模型的效率来源。

