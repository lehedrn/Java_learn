package com.coderlee.concurrent.chapter06;

/**
 * 完整缓存行填充演示类
 * 
 * <p>该类用于演示缓存行填充(Cache Line Padding)技术，用于避免伪共享(False Sharing)问题。
 * 在多核处理器系统中，不同CPU核心可能会同时访问同一个缓存行中的不同变量，
 * 即使这些变量彼此独立，也会因为缓存一致性协议而导致性能下降。</p>
 * 
 * <p>该类通过填充额外的double变量来确保{@link #value}变量独占一个完整的缓存行。
 * 典型的缓存行大小为64字节，一个double类型占用8字节，因此使用1个volatile double变量
 * 加上6个普通double变量(总共7*8=56字节)，再加上对象头信息，刚好凑够64字节，可以使[value]字段独占缓存行。</p>
 * 
 * <p>注意：这是一种性能优化技术，在实际应用中需要根据具体场景权衡内存使用和性能提升。</p>
 * 
 * @see VolatileNoCacheLineDouble
 */
public class FullCacheLineDouble {
    
    /**
     * 核心数据字段，使用volatile关键字保证可见性和有序性
     * 
     * <p>该字段可能是多线程环境下频繁访问和修改的热点数据。
     * 使用volatile关键字确保：
     * <ul>
     *   <li>对[value]的写入对其他线程立即可见</li>
     *   <li>禁止指令重排序，保证内存屏障语义</li>
     * </ul>
     * </p>
     * 
     * <p>通过缓存行填充技术，避免与其他变量共享同一个缓存行，
     * 减少因缓存一致性协议导致的性能损耗。</p>
     */
    public volatile double value = 0;
    
    /**
     * 缓存行填充字段1
     * 
     * <p>用于填充缓存行，避免[value]字段与其他变量共享缓存行。
     * 这些字段没有业务意义，仅仅是为了占用缓存行空间。</p>
     */
    public double d1;
    
    /**
     * 缓存行填充字段2
     * 
     * <p>用于填充缓存行，避免[value]字段与其他变量共享缓存行。
     * 这些字段没有业务意义，仅仅是为了占用缓存行空间。</p>
     */
    public double d2;
    
    /**
     * 缓存行填充字段3
     * 
     * <p>用于填充缓存行，避免[value]字段与其他变量共享缓存行。
     * 这些字段没有业务意义，仅仅是为了占用缓存行空间。</p>
     */
    public double d3;
    
    /**
     * 缓存行填充字段4
     * 
     * <p>用于填充缓存行，避免[value]字段与其他变量共享缓存行。
     * 这些字段没有业务意义，仅仅是为了占用缓存行空间。</p>
     */
    public double d4;
    
    /**
     * 缓存行填充字段5
     * 
     * <p>用于填充缓存行，避免[value]字段与其他变量共享缓存行。
     * 这些字段没有业务意义，仅仅是为了占用缓存行空间。</p>
     */
    public double d5;
    
    /**
     * 缓存行填充字段6
     * 
     * <p>用于填充缓存行，避免[value]字段与其他变量共享缓存行。
     * 这些字段没有业务意义，仅仅是为了占用缓存行空间。</p>
     */
    public double d6;
}